// Code generated by counterfeiter. DO NOT EDIT.
package clientfakes

import (
	"sync"

	"github.com/alphagov/paas-cf-conduit/client"
	cfclient "github.com/cloudfoundry-community/go-cfclient"
)

type FakeClient struct {
	AppSSHEndpointStub        func() string
	appSSHEndpointMutex       sync.RWMutex
	appSSHEndpointArgsForCall []struct {
	}
	appSSHEndpointReturns struct {
		result1 string
	}
	appSSHEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	AppSSHHostKeyFingerprintStub        func() string
	appSSHHostKeyFingerprintMutex       sync.RWMutex
	appSSHHostKeyFingerprintArgsForCall []struct {
	}
	appSSHHostKeyFingerprintReturns struct {
		result1 string
	}
	appSSHHostKeyFingerprintReturnsOnCall map[int]struct {
		result1 string
	}
	BindServiceStub        func(string, string, map[string]interface{}) (*client.Credentials, error)
	bindServiceMutex       sync.RWMutex
	bindServiceArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 map[string]interface{}
	}
	bindServiceReturns struct {
		result1 *client.Credentials
		result2 error
	}
	bindServiceReturnsOnCall map[int]struct {
		result1 *client.Credentials
		result2 error
	}
	CreateAppStub        func(string, string) (string, error)
	createAppMutex       sync.RWMutex
	createAppArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createAppReturns struct {
		result1 string
		result2 error
	}
	createAppReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DestroyAppStub        func(string) error
	destroyAppMutex       sync.RWMutex
	destroyAppArgsForCall []struct {
		arg1 string
	}
	destroyAppReturns struct {
		result1 error
	}
	destroyAppReturnsOnCall map[int]struct {
		result1 error
	}
	GetAppByNameStub        func(string, string, string) (*cfclient.App, error)
	getAppByNameMutex       sync.RWMutex
	getAppByNameArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	getAppByNameReturns struct {
		result1 *cfclient.App
		result2 error
	}
	getAppByNameReturnsOnCall map[int]struct {
		result1 *cfclient.App
		result2 error
	}
	GetAppEnvStub        func(string) (*client.Env, error)
	getAppEnvMutex       sync.RWMutex
	getAppEnvArgsForCall []struct {
		arg1 string
	}
	getAppEnvReturns struct {
		result1 *client.Env
		result2 error
	}
	getAppEnvReturnsOnCall map[int]struct {
		result1 *client.Env
		result2 error
	}
	GetOrgByNameStub        func(string) (*cfclient.Org, error)
	getOrgByNameMutex       sync.RWMutex
	getOrgByNameArgsForCall []struct {
		arg1 string
	}
	getOrgByNameReturns struct {
		result1 *cfclient.Org
		result2 error
	}
	getOrgByNameReturnsOnCall map[int]struct {
		result1 *cfclient.Org
		result2 error
	}
	GetServiceBindingsStub        func(...string) (map[string]*cfclient.ServiceBinding, error)
	getServiceBindingsMutex       sync.RWMutex
	getServiceBindingsArgsForCall []struct {
		arg1 []string
	}
	getServiceBindingsReturns struct {
		result1 map[string]*cfclient.ServiceBinding
		result2 error
	}
	getServiceBindingsReturnsOnCall map[int]struct {
		result1 map[string]*cfclient.ServiceBinding
		result2 error
	}
	GetServiceInstancesStub        func(...string) (map[string]*cfclient.ServiceInstance, error)
	getServiceInstancesMutex       sync.RWMutex
	getServiceInstancesArgsForCall []struct {
		arg1 []string
	}
	getServiceInstancesReturns struct {
		result1 map[string]*cfclient.ServiceInstance
		result2 error
	}
	getServiceInstancesReturnsOnCall map[int]struct {
		result1 map[string]*cfclient.ServiceInstance
		result2 error
	}
	GetSpaceByNameStub        func(string, string) (*cfclient.Space, error)
	getSpaceByNameMutex       sync.RWMutex
	getSpaceByNameArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getSpaceByNameReturns struct {
		result1 *cfclient.Space
		result2 error
	}
	getSpaceByNameReturnsOnCall map[int]struct {
		result1 *cfclient.Space
		result2 error
	}
	PollForAppStateStub        func(string, string, int) error
	pollForAppStateMutex       sync.RWMutex
	pollForAppStateArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
	}
	pollForAppStateReturns struct {
		result1 error
	}
	pollForAppStateReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshAccessTokenStub        func() error
	refreshAccessTokenMutex       sync.RWMutex
	refreshAccessTokenArgsForCall []struct {
	}
	refreshAccessTokenReturns struct {
		result1 error
	}
	refreshAccessTokenReturnsOnCall map[int]struct {
		result1 error
	}
	SSHCodeStub        func() (string, error)
	sSHCodeMutex       sync.RWMutex
	sSHCodeArgsForCall []struct {
	}
	sSHCodeReturns struct {
		result1 string
		result2 error
	}
	sSHCodeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StartAppStub        func(string) error
	startAppMutex       sync.RWMutex
	startAppArgsForCall []struct {
		arg1 string
	}
	startAppReturns struct {
		result1 error
	}
	startAppReturnsOnCall map[int]struct {
		result1 error
	}
	UploadStaticAppBitsStub        func(string) error
	uploadStaticAppBitsMutex       sync.RWMutex
	uploadStaticAppBitsArgsForCall []struct {
		arg1 string
	}
	uploadStaticAppBitsReturns struct {
		result1 error
	}
	uploadStaticAppBitsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AppSSHEndpoint() string {
	fake.appSSHEndpointMutex.Lock()
	ret, specificReturn := fake.appSSHEndpointReturnsOnCall[len(fake.appSSHEndpointArgsForCall)]
	fake.appSSHEndpointArgsForCall = append(fake.appSSHEndpointArgsForCall, struct {
	}{})
	stub := fake.AppSSHEndpointStub
	fakeReturns := fake.appSSHEndpointReturns
	fake.recordInvocation("AppSSHEndpoint", []interface{}{})
	fake.appSSHEndpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AppSSHEndpointCallCount() int {
	fake.appSSHEndpointMutex.RLock()
	defer fake.appSSHEndpointMutex.RUnlock()
	return len(fake.appSSHEndpointArgsForCall)
}

func (fake *FakeClient) AppSSHEndpointCalls(stub func() string) {
	fake.appSSHEndpointMutex.Lock()
	defer fake.appSSHEndpointMutex.Unlock()
	fake.AppSSHEndpointStub = stub
}

func (fake *FakeClient) AppSSHEndpointReturns(result1 string) {
	fake.appSSHEndpointMutex.Lock()
	defer fake.appSSHEndpointMutex.Unlock()
	fake.AppSSHEndpointStub = nil
	fake.appSSHEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) AppSSHEndpointReturnsOnCall(i int, result1 string) {
	fake.appSSHEndpointMutex.Lock()
	defer fake.appSSHEndpointMutex.Unlock()
	fake.AppSSHEndpointStub = nil
	if fake.appSSHEndpointReturnsOnCall == nil {
		fake.appSSHEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.appSSHEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) AppSSHHostKeyFingerprint() string {
	fake.appSSHHostKeyFingerprintMutex.Lock()
	ret, specificReturn := fake.appSSHHostKeyFingerprintReturnsOnCall[len(fake.appSSHHostKeyFingerprintArgsForCall)]
	fake.appSSHHostKeyFingerprintArgsForCall = append(fake.appSSHHostKeyFingerprintArgsForCall, struct {
	}{})
	stub := fake.AppSSHHostKeyFingerprintStub
	fakeReturns := fake.appSSHHostKeyFingerprintReturns
	fake.recordInvocation("AppSSHHostKeyFingerprint", []interface{}{})
	fake.appSSHHostKeyFingerprintMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) AppSSHHostKeyFingerprintCallCount() int {
	fake.appSSHHostKeyFingerprintMutex.RLock()
	defer fake.appSSHHostKeyFingerprintMutex.RUnlock()
	return len(fake.appSSHHostKeyFingerprintArgsForCall)
}

func (fake *FakeClient) AppSSHHostKeyFingerprintCalls(stub func() string) {
	fake.appSSHHostKeyFingerprintMutex.Lock()
	defer fake.appSSHHostKeyFingerprintMutex.Unlock()
	fake.AppSSHHostKeyFingerprintStub = stub
}

func (fake *FakeClient) AppSSHHostKeyFingerprintReturns(result1 string) {
	fake.appSSHHostKeyFingerprintMutex.Lock()
	defer fake.appSSHHostKeyFingerprintMutex.Unlock()
	fake.AppSSHHostKeyFingerprintStub = nil
	fake.appSSHHostKeyFingerprintReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) AppSSHHostKeyFingerprintReturnsOnCall(i int, result1 string) {
	fake.appSSHHostKeyFingerprintMutex.Lock()
	defer fake.appSSHHostKeyFingerprintMutex.Unlock()
	fake.AppSSHHostKeyFingerprintStub = nil
	if fake.appSSHHostKeyFingerprintReturnsOnCall == nil {
		fake.appSSHHostKeyFingerprintReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.appSSHHostKeyFingerprintReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClient) BindService(arg1 string, arg2 string, arg3 map[string]interface{}) (*client.Credentials, error) {
	fake.bindServiceMutex.Lock()
	ret, specificReturn := fake.bindServiceReturnsOnCall[len(fake.bindServiceArgsForCall)]
	fake.bindServiceArgsForCall = append(fake.bindServiceArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 map[string]interface{}
	}{arg1, arg2, arg3})
	stub := fake.BindServiceStub
	fakeReturns := fake.bindServiceReturns
	fake.recordInvocation("BindService", []interface{}{arg1, arg2, arg3})
	fake.bindServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) BindServiceCallCount() int {
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	return len(fake.bindServiceArgsForCall)
}

func (fake *FakeClient) BindServiceCalls(stub func(string, string, map[string]interface{}) (*client.Credentials, error)) {
	fake.bindServiceMutex.Lock()
	defer fake.bindServiceMutex.Unlock()
	fake.BindServiceStub = stub
}

func (fake *FakeClient) BindServiceArgsForCall(i int) (string, string, map[string]interface{}) {
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	argsForCall := fake.bindServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) BindServiceReturns(result1 *client.Credentials, result2 error) {
	fake.bindServiceMutex.Lock()
	defer fake.bindServiceMutex.Unlock()
	fake.BindServiceStub = nil
	fake.bindServiceReturns = struct {
		result1 *client.Credentials
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BindServiceReturnsOnCall(i int, result1 *client.Credentials, result2 error) {
	fake.bindServiceMutex.Lock()
	defer fake.bindServiceMutex.Unlock()
	fake.BindServiceStub = nil
	if fake.bindServiceReturnsOnCall == nil {
		fake.bindServiceReturnsOnCall = make(map[int]struct {
			result1 *client.Credentials
			result2 error
		})
	}
	fake.bindServiceReturnsOnCall[i] = struct {
		result1 *client.Credentials
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateApp(arg1 string, arg2 string) (string, error) {
	fake.createAppMutex.Lock()
	ret, specificReturn := fake.createAppReturnsOnCall[len(fake.createAppArgsForCall)]
	fake.createAppArgsForCall = append(fake.createAppArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateAppStub
	fakeReturns := fake.createAppReturns
	fake.recordInvocation("CreateApp", []interface{}{arg1, arg2})
	fake.createAppMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateAppCallCount() int {
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	return len(fake.createAppArgsForCall)
}

func (fake *FakeClient) CreateAppCalls(stub func(string, string) (string, error)) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = stub
}

func (fake *FakeClient) CreateAppArgsForCall(i int) (string, string) {
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	argsForCall := fake.createAppArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CreateAppReturns(result1 string, result2 error) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = nil
	fake.createAppReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateAppReturnsOnCall(i int, result1 string, result2 error) {
	fake.createAppMutex.Lock()
	defer fake.createAppMutex.Unlock()
	fake.CreateAppStub = nil
	if fake.createAppReturnsOnCall == nil {
		fake.createAppReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createAppReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DestroyApp(arg1 string) error {
	fake.destroyAppMutex.Lock()
	ret, specificReturn := fake.destroyAppReturnsOnCall[len(fake.destroyAppArgsForCall)]
	fake.destroyAppArgsForCall = append(fake.destroyAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DestroyAppStub
	fakeReturns := fake.destroyAppReturns
	fake.recordInvocation("DestroyApp", []interface{}{arg1})
	fake.destroyAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DestroyAppCallCount() int {
	fake.destroyAppMutex.RLock()
	defer fake.destroyAppMutex.RUnlock()
	return len(fake.destroyAppArgsForCall)
}

func (fake *FakeClient) DestroyAppCalls(stub func(string) error) {
	fake.destroyAppMutex.Lock()
	defer fake.destroyAppMutex.Unlock()
	fake.DestroyAppStub = stub
}

func (fake *FakeClient) DestroyAppArgsForCall(i int) string {
	fake.destroyAppMutex.RLock()
	defer fake.destroyAppMutex.RUnlock()
	argsForCall := fake.destroyAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DestroyAppReturns(result1 error) {
	fake.destroyAppMutex.Lock()
	defer fake.destroyAppMutex.Unlock()
	fake.DestroyAppStub = nil
	fake.destroyAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyAppReturnsOnCall(i int, result1 error) {
	fake.destroyAppMutex.Lock()
	defer fake.destroyAppMutex.Unlock()
	fake.DestroyAppStub = nil
	if fake.destroyAppReturnsOnCall == nil {
		fake.destroyAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetAppByName(arg1 string, arg2 string, arg3 string) (*cfclient.App, error) {
	fake.getAppByNameMutex.Lock()
	ret, specificReturn := fake.getAppByNameReturnsOnCall[len(fake.getAppByNameArgsForCall)]
	fake.getAppByNameArgsForCall = append(fake.getAppByNameArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetAppByNameStub
	fakeReturns := fake.getAppByNameReturns
	fake.recordInvocation("GetAppByName", []interface{}{arg1, arg2, arg3})
	fake.getAppByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetAppByNameCallCount() int {
	fake.getAppByNameMutex.RLock()
	defer fake.getAppByNameMutex.RUnlock()
	return len(fake.getAppByNameArgsForCall)
}

func (fake *FakeClient) GetAppByNameCalls(stub func(string, string, string) (*cfclient.App, error)) {
	fake.getAppByNameMutex.Lock()
	defer fake.getAppByNameMutex.Unlock()
	fake.GetAppByNameStub = stub
}

func (fake *FakeClient) GetAppByNameArgsForCall(i int) (string, string, string) {
	fake.getAppByNameMutex.RLock()
	defer fake.getAppByNameMutex.RUnlock()
	argsForCall := fake.getAppByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) GetAppByNameReturns(result1 *cfclient.App, result2 error) {
	fake.getAppByNameMutex.Lock()
	defer fake.getAppByNameMutex.Unlock()
	fake.GetAppByNameStub = nil
	fake.getAppByNameReturns = struct {
		result1 *cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAppByNameReturnsOnCall(i int, result1 *cfclient.App, result2 error) {
	fake.getAppByNameMutex.Lock()
	defer fake.getAppByNameMutex.Unlock()
	fake.GetAppByNameStub = nil
	if fake.getAppByNameReturnsOnCall == nil {
		fake.getAppByNameReturnsOnCall = make(map[int]struct {
			result1 *cfclient.App
			result2 error
		})
	}
	fake.getAppByNameReturnsOnCall[i] = struct {
		result1 *cfclient.App
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAppEnv(arg1 string) (*client.Env, error) {
	fake.getAppEnvMutex.Lock()
	ret, specificReturn := fake.getAppEnvReturnsOnCall[len(fake.getAppEnvArgsForCall)]
	fake.getAppEnvArgsForCall = append(fake.getAppEnvArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAppEnvStub
	fakeReturns := fake.getAppEnvReturns
	fake.recordInvocation("GetAppEnv", []interface{}{arg1})
	fake.getAppEnvMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetAppEnvCallCount() int {
	fake.getAppEnvMutex.RLock()
	defer fake.getAppEnvMutex.RUnlock()
	return len(fake.getAppEnvArgsForCall)
}

func (fake *FakeClient) GetAppEnvCalls(stub func(string) (*client.Env, error)) {
	fake.getAppEnvMutex.Lock()
	defer fake.getAppEnvMutex.Unlock()
	fake.GetAppEnvStub = stub
}

func (fake *FakeClient) GetAppEnvArgsForCall(i int) string {
	fake.getAppEnvMutex.RLock()
	defer fake.getAppEnvMutex.RUnlock()
	argsForCall := fake.getAppEnvArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetAppEnvReturns(result1 *client.Env, result2 error) {
	fake.getAppEnvMutex.Lock()
	defer fake.getAppEnvMutex.Unlock()
	fake.GetAppEnvStub = nil
	fake.getAppEnvReturns = struct {
		result1 *client.Env
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetAppEnvReturnsOnCall(i int, result1 *client.Env, result2 error) {
	fake.getAppEnvMutex.Lock()
	defer fake.getAppEnvMutex.Unlock()
	fake.GetAppEnvStub = nil
	if fake.getAppEnvReturnsOnCall == nil {
		fake.getAppEnvReturnsOnCall = make(map[int]struct {
			result1 *client.Env
			result2 error
		})
	}
	fake.getAppEnvReturnsOnCall[i] = struct {
		result1 *client.Env
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgByName(arg1 string) (*cfclient.Org, error) {
	fake.getOrgByNameMutex.Lock()
	ret, specificReturn := fake.getOrgByNameReturnsOnCall[len(fake.getOrgByNameArgsForCall)]
	fake.getOrgByNameArgsForCall = append(fake.getOrgByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetOrgByNameStub
	fakeReturns := fake.getOrgByNameReturns
	fake.recordInvocation("GetOrgByName", []interface{}{arg1})
	fake.getOrgByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetOrgByNameCallCount() int {
	fake.getOrgByNameMutex.RLock()
	defer fake.getOrgByNameMutex.RUnlock()
	return len(fake.getOrgByNameArgsForCall)
}

func (fake *FakeClient) GetOrgByNameCalls(stub func(string) (*cfclient.Org, error)) {
	fake.getOrgByNameMutex.Lock()
	defer fake.getOrgByNameMutex.Unlock()
	fake.GetOrgByNameStub = stub
}

func (fake *FakeClient) GetOrgByNameArgsForCall(i int) string {
	fake.getOrgByNameMutex.RLock()
	defer fake.getOrgByNameMutex.RUnlock()
	argsForCall := fake.getOrgByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetOrgByNameReturns(result1 *cfclient.Org, result2 error) {
	fake.getOrgByNameMutex.Lock()
	defer fake.getOrgByNameMutex.Unlock()
	fake.GetOrgByNameStub = nil
	fake.getOrgByNameReturns = struct {
		result1 *cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetOrgByNameReturnsOnCall(i int, result1 *cfclient.Org, result2 error) {
	fake.getOrgByNameMutex.Lock()
	defer fake.getOrgByNameMutex.Unlock()
	fake.GetOrgByNameStub = nil
	if fake.getOrgByNameReturnsOnCall == nil {
		fake.getOrgByNameReturnsOnCall = make(map[int]struct {
			result1 *cfclient.Org
			result2 error
		})
	}
	fake.getOrgByNameReturnsOnCall[i] = struct {
		result1 *cfclient.Org
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceBindings(arg1 ...string) (map[string]*cfclient.ServiceBinding, error) {
	fake.getServiceBindingsMutex.Lock()
	ret, specificReturn := fake.getServiceBindingsReturnsOnCall[len(fake.getServiceBindingsArgsForCall)]
	fake.getServiceBindingsArgsForCall = append(fake.getServiceBindingsArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.GetServiceBindingsStub
	fakeReturns := fake.getServiceBindingsReturns
	fake.recordInvocation("GetServiceBindings", []interface{}{arg1})
	fake.getServiceBindingsMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetServiceBindingsCallCount() int {
	fake.getServiceBindingsMutex.RLock()
	defer fake.getServiceBindingsMutex.RUnlock()
	return len(fake.getServiceBindingsArgsForCall)
}

func (fake *FakeClient) GetServiceBindingsCalls(stub func(...string) (map[string]*cfclient.ServiceBinding, error)) {
	fake.getServiceBindingsMutex.Lock()
	defer fake.getServiceBindingsMutex.Unlock()
	fake.GetServiceBindingsStub = stub
}

func (fake *FakeClient) GetServiceBindingsArgsForCall(i int) []string {
	fake.getServiceBindingsMutex.RLock()
	defer fake.getServiceBindingsMutex.RUnlock()
	argsForCall := fake.getServiceBindingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetServiceBindingsReturns(result1 map[string]*cfclient.ServiceBinding, result2 error) {
	fake.getServiceBindingsMutex.Lock()
	defer fake.getServiceBindingsMutex.Unlock()
	fake.GetServiceBindingsStub = nil
	fake.getServiceBindingsReturns = struct {
		result1 map[string]*cfclient.ServiceBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceBindingsReturnsOnCall(i int, result1 map[string]*cfclient.ServiceBinding, result2 error) {
	fake.getServiceBindingsMutex.Lock()
	defer fake.getServiceBindingsMutex.Unlock()
	fake.GetServiceBindingsStub = nil
	if fake.getServiceBindingsReturnsOnCall == nil {
		fake.getServiceBindingsReturnsOnCall = make(map[int]struct {
			result1 map[string]*cfclient.ServiceBinding
			result2 error
		})
	}
	fake.getServiceBindingsReturnsOnCall[i] = struct {
		result1 map[string]*cfclient.ServiceBinding
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceInstances(arg1 ...string) (map[string]*cfclient.ServiceInstance, error) {
	fake.getServiceInstancesMutex.Lock()
	ret, specificReturn := fake.getServiceInstancesReturnsOnCall[len(fake.getServiceInstancesArgsForCall)]
	fake.getServiceInstancesArgsForCall = append(fake.getServiceInstancesArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.GetServiceInstancesStub
	fakeReturns := fake.getServiceInstancesReturns
	fake.recordInvocation("GetServiceInstances", []interface{}{arg1})
	fake.getServiceInstancesMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetServiceInstancesCallCount() int {
	fake.getServiceInstancesMutex.RLock()
	defer fake.getServiceInstancesMutex.RUnlock()
	return len(fake.getServiceInstancesArgsForCall)
}

func (fake *FakeClient) GetServiceInstancesCalls(stub func(...string) (map[string]*cfclient.ServiceInstance, error)) {
	fake.getServiceInstancesMutex.Lock()
	defer fake.getServiceInstancesMutex.Unlock()
	fake.GetServiceInstancesStub = stub
}

func (fake *FakeClient) GetServiceInstancesArgsForCall(i int) []string {
	fake.getServiceInstancesMutex.RLock()
	defer fake.getServiceInstancesMutex.RUnlock()
	argsForCall := fake.getServiceInstancesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetServiceInstancesReturns(result1 map[string]*cfclient.ServiceInstance, result2 error) {
	fake.getServiceInstancesMutex.Lock()
	defer fake.getServiceInstancesMutex.Unlock()
	fake.GetServiceInstancesStub = nil
	fake.getServiceInstancesReturns = struct {
		result1 map[string]*cfclient.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetServiceInstancesReturnsOnCall(i int, result1 map[string]*cfclient.ServiceInstance, result2 error) {
	fake.getServiceInstancesMutex.Lock()
	defer fake.getServiceInstancesMutex.Unlock()
	fake.GetServiceInstancesStub = nil
	if fake.getServiceInstancesReturnsOnCall == nil {
		fake.getServiceInstancesReturnsOnCall = make(map[int]struct {
			result1 map[string]*cfclient.ServiceInstance
			result2 error
		})
	}
	fake.getServiceInstancesReturnsOnCall[i] = struct {
		result1 map[string]*cfclient.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSpaceByName(arg1 string, arg2 string) (*cfclient.Space, error) {
	fake.getSpaceByNameMutex.Lock()
	ret, specificReturn := fake.getSpaceByNameReturnsOnCall[len(fake.getSpaceByNameArgsForCall)]
	fake.getSpaceByNameArgsForCall = append(fake.getSpaceByNameArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSpaceByNameStub
	fakeReturns := fake.getSpaceByNameReturns
	fake.recordInvocation("GetSpaceByName", []interface{}{arg1, arg2})
	fake.getSpaceByNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetSpaceByNameCallCount() int {
	fake.getSpaceByNameMutex.RLock()
	defer fake.getSpaceByNameMutex.RUnlock()
	return len(fake.getSpaceByNameArgsForCall)
}

func (fake *FakeClient) GetSpaceByNameCalls(stub func(string, string) (*cfclient.Space, error)) {
	fake.getSpaceByNameMutex.Lock()
	defer fake.getSpaceByNameMutex.Unlock()
	fake.GetSpaceByNameStub = stub
}

func (fake *FakeClient) GetSpaceByNameArgsForCall(i int) (string, string) {
	fake.getSpaceByNameMutex.RLock()
	defer fake.getSpaceByNameMutex.RUnlock()
	argsForCall := fake.getSpaceByNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetSpaceByNameReturns(result1 *cfclient.Space, result2 error) {
	fake.getSpaceByNameMutex.Lock()
	defer fake.getSpaceByNameMutex.Unlock()
	fake.GetSpaceByNameStub = nil
	fake.getSpaceByNameReturns = struct {
		result1 *cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetSpaceByNameReturnsOnCall(i int, result1 *cfclient.Space, result2 error) {
	fake.getSpaceByNameMutex.Lock()
	defer fake.getSpaceByNameMutex.Unlock()
	fake.GetSpaceByNameStub = nil
	if fake.getSpaceByNameReturnsOnCall == nil {
		fake.getSpaceByNameReturnsOnCall = make(map[int]struct {
			result1 *cfclient.Space
			result2 error
		})
	}
	fake.getSpaceByNameReturnsOnCall[i] = struct {
		result1 *cfclient.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PollForAppState(arg1 string, arg2 string, arg3 int) error {
	fake.pollForAppStateMutex.Lock()
	ret, specificReturn := fake.pollForAppStateReturnsOnCall[len(fake.pollForAppStateArgsForCall)]
	fake.pollForAppStateArgsForCall = append(fake.pollForAppStateArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.PollForAppStateStub
	fakeReturns := fake.pollForAppStateReturns
	fake.recordInvocation("PollForAppState", []interface{}{arg1, arg2, arg3})
	fake.pollForAppStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PollForAppStateCallCount() int {
	fake.pollForAppStateMutex.RLock()
	defer fake.pollForAppStateMutex.RUnlock()
	return len(fake.pollForAppStateArgsForCall)
}

func (fake *FakeClient) PollForAppStateCalls(stub func(string, string, int) error) {
	fake.pollForAppStateMutex.Lock()
	defer fake.pollForAppStateMutex.Unlock()
	fake.PollForAppStateStub = stub
}

func (fake *FakeClient) PollForAppStateArgsForCall(i int) (string, string, int) {
	fake.pollForAppStateMutex.RLock()
	defer fake.pollForAppStateMutex.RUnlock()
	argsForCall := fake.pollForAppStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) PollForAppStateReturns(result1 error) {
	fake.pollForAppStateMutex.Lock()
	defer fake.pollForAppStateMutex.Unlock()
	fake.PollForAppStateStub = nil
	fake.pollForAppStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) PollForAppStateReturnsOnCall(i int, result1 error) {
	fake.pollForAppStateMutex.Lock()
	defer fake.pollForAppStateMutex.Unlock()
	fake.PollForAppStateStub = nil
	if fake.pollForAppStateReturnsOnCall == nil {
		fake.pollForAppStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pollForAppStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RefreshAccessToken() error {
	fake.refreshAccessTokenMutex.Lock()
	ret, specificReturn := fake.refreshAccessTokenReturnsOnCall[len(fake.refreshAccessTokenArgsForCall)]
	fake.refreshAccessTokenArgsForCall = append(fake.refreshAccessTokenArgsForCall, struct {
	}{})
	stub := fake.RefreshAccessTokenStub
	fakeReturns := fake.refreshAccessTokenReturns
	fake.recordInvocation("RefreshAccessToken", []interface{}{})
	fake.refreshAccessTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) RefreshAccessTokenCallCount() int {
	fake.refreshAccessTokenMutex.RLock()
	defer fake.refreshAccessTokenMutex.RUnlock()
	return len(fake.refreshAccessTokenArgsForCall)
}

func (fake *FakeClient) RefreshAccessTokenCalls(stub func() error) {
	fake.refreshAccessTokenMutex.Lock()
	defer fake.refreshAccessTokenMutex.Unlock()
	fake.RefreshAccessTokenStub = stub
}

func (fake *FakeClient) RefreshAccessTokenReturns(result1 error) {
	fake.refreshAccessTokenMutex.Lock()
	defer fake.refreshAccessTokenMutex.Unlock()
	fake.RefreshAccessTokenStub = nil
	fake.refreshAccessTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) RefreshAccessTokenReturnsOnCall(i int, result1 error) {
	fake.refreshAccessTokenMutex.Lock()
	defer fake.refreshAccessTokenMutex.Unlock()
	fake.RefreshAccessTokenStub = nil
	if fake.refreshAccessTokenReturnsOnCall == nil {
		fake.refreshAccessTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshAccessTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SSHCode() (string, error) {
	fake.sSHCodeMutex.Lock()
	ret, specificReturn := fake.sSHCodeReturnsOnCall[len(fake.sSHCodeArgsForCall)]
	fake.sSHCodeArgsForCall = append(fake.sSHCodeArgsForCall, struct {
	}{})
	stub := fake.SSHCodeStub
	fakeReturns := fake.sSHCodeReturns
	fake.recordInvocation("SSHCode", []interface{}{})
	fake.sSHCodeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SSHCodeCallCount() int {
	fake.sSHCodeMutex.RLock()
	defer fake.sSHCodeMutex.RUnlock()
	return len(fake.sSHCodeArgsForCall)
}

func (fake *FakeClient) SSHCodeCalls(stub func() (string, error)) {
	fake.sSHCodeMutex.Lock()
	defer fake.sSHCodeMutex.Unlock()
	fake.SSHCodeStub = stub
}

func (fake *FakeClient) SSHCodeReturns(result1 string, result2 error) {
	fake.sSHCodeMutex.Lock()
	defer fake.sSHCodeMutex.Unlock()
	fake.SSHCodeStub = nil
	fake.sSHCodeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SSHCodeReturnsOnCall(i int, result1 string, result2 error) {
	fake.sSHCodeMutex.Lock()
	defer fake.sSHCodeMutex.Unlock()
	fake.SSHCodeStub = nil
	if fake.sSHCodeReturnsOnCall == nil {
		fake.sSHCodeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.sSHCodeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StartApp(arg1 string) error {
	fake.startAppMutex.Lock()
	ret, specificReturn := fake.startAppReturnsOnCall[len(fake.startAppArgsForCall)]
	fake.startAppArgsForCall = append(fake.startAppArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StartAppStub
	fakeReturns := fake.startAppReturns
	fake.recordInvocation("StartApp", []interface{}{arg1})
	fake.startAppMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) StartAppCallCount() int {
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	return len(fake.startAppArgsForCall)
}

func (fake *FakeClient) StartAppCalls(stub func(string) error) {
	fake.startAppMutex.Lock()
	defer fake.startAppMutex.Unlock()
	fake.StartAppStub = stub
}

func (fake *FakeClient) StartAppArgsForCall(i int) string {
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	argsForCall := fake.startAppArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StartAppReturns(result1 error) {
	fake.startAppMutex.Lock()
	defer fake.startAppMutex.Unlock()
	fake.StartAppStub = nil
	fake.startAppReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) StartAppReturnsOnCall(i int, result1 error) {
	fake.startAppMutex.Lock()
	defer fake.startAppMutex.Unlock()
	fake.StartAppStub = nil
	if fake.startAppReturnsOnCall == nil {
		fake.startAppReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startAppReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UploadStaticAppBits(arg1 string) error {
	fake.uploadStaticAppBitsMutex.Lock()
	ret, specificReturn := fake.uploadStaticAppBitsReturnsOnCall[len(fake.uploadStaticAppBitsArgsForCall)]
	fake.uploadStaticAppBitsArgsForCall = append(fake.uploadStaticAppBitsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UploadStaticAppBitsStub
	fakeReturns := fake.uploadStaticAppBitsReturns
	fake.recordInvocation("UploadStaticAppBits", []interface{}{arg1})
	fake.uploadStaticAppBitsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) UploadStaticAppBitsCallCount() int {
	fake.uploadStaticAppBitsMutex.RLock()
	defer fake.uploadStaticAppBitsMutex.RUnlock()
	return len(fake.uploadStaticAppBitsArgsForCall)
}

func (fake *FakeClient) UploadStaticAppBitsCalls(stub func(string) error) {
	fake.uploadStaticAppBitsMutex.Lock()
	defer fake.uploadStaticAppBitsMutex.Unlock()
	fake.UploadStaticAppBitsStub = stub
}

func (fake *FakeClient) UploadStaticAppBitsArgsForCall(i int) string {
	fake.uploadStaticAppBitsMutex.RLock()
	defer fake.uploadStaticAppBitsMutex.RUnlock()
	argsForCall := fake.uploadStaticAppBitsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UploadStaticAppBitsReturns(result1 error) {
	fake.uploadStaticAppBitsMutex.Lock()
	defer fake.uploadStaticAppBitsMutex.Unlock()
	fake.UploadStaticAppBitsStub = nil
	fake.uploadStaticAppBitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UploadStaticAppBitsReturnsOnCall(i int, result1 error) {
	fake.uploadStaticAppBitsMutex.Lock()
	defer fake.uploadStaticAppBitsMutex.Unlock()
	fake.UploadStaticAppBitsStub = nil
	if fake.uploadStaticAppBitsReturnsOnCall == nil {
		fake.uploadStaticAppBitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadStaticAppBitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appSSHEndpointMutex.RLock()
	defer fake.appSSHEndpointMutex.RUnlock()
	fake.appSSHHostKeyFingerprintMutex.RLock()
	defer fake.appSSHHostKeyFingerprintMutex.RUnlock()
	fake.bindServiceMutex.RLock()
	defer fake.bindServiceMutex.RUnlock()
	fake.createAppMutex.RLock()
	defer fake.createAppMutex.RUnlock()
	fake.destroyAppMutex.RLock()
	defer fake.destroyAppMutex.RUnlock()
	fake.getAppByNameMutex.RLock()
	defer fake.getAppByNameMutex.RUnlock()
	fake.getAppEnvMutex.RLock()
	defer fake.getAppEnvMutex.RUnlock()
	fake.getOrgByNameMutex.RLock()
	defer fake.getOrgByNameMutex.RUnlock()
	fake.getServiceBindingsMutex.RLock()
	defer fake.getServiceBindingsMutex.RUnlock()
	fake.getServiceInstancesMutex.RLock()
	defer fake.getServiceInstancesMutex.RUnlock()
	fake.getSpaceByNameMutex.RLock()
	defer fake.getSpaceByNameMutex.RUnlock()
	fake.pollForAppStateMutex.RLock()
	defer fake.pollForAppStateMutex.RUnlock()
	fake.refreshAccessTokenMutex.RLock()
	defer fake.refreshAccessTokenMutex.RUnlock()
	fake.sSHCodeMutex.RLock()
	defer fake.sSHCodeMutex.RUnlock()
	fake.startAppMutex.RLock()
	defer fake.startAppMutex.RUnlock()
	fake.uploadStaticAppBitsMutex.RLock()
	defer fake.uploadStaticAppBitsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
